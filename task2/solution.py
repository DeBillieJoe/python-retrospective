from collections import OrderedDict


def groupby(func, seq):
    """
    Return dictionary of grouped items.

    Values in `seq` and keys generated by `func`
    """

    result = {}

    for element in seq:
        result.setdefault(func(element), []).append(element)

    return result


def zip_with(func, *iterables):
    """
    Generate sequence of elements, where the
    nth element is the result of `func` applied
    to the nth elements of all iterables.
    """

    for args in zip(*iterables):
        yield func(*args)


def compose(func_one, func_two):
    """Return the composition of two functions."""
    return lambda arg: func_one(func_two(arg))


def iterate(func):
    """
    Generate infinite sequence of compositions of `func`.

    The first element is the identity of `func`.

    Return the iteration of `func`.
    """

    current_composition = lambda ident: ident

    while True:
        yield current_composition
        current_composition = compose(func, current_composition)


def cache(func, cache_size):
    """
    Return a function that caches the last
    `cache_size` results of `func`.
    """
    if cache_size <= 0:
        return func

    cache_store = OrderedDict()

    def cached_func(*args):
        if args not in cache_store:
            if len(cache_store) >= cache_size:
                cache_store.popitem(False)

            cache_store[args] = func(*args)

        return cache_store[args]

    return cached_func
